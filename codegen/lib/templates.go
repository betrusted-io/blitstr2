// Copyright (c) 2022 Sam Blenny
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
package lib

import (
	"bytes"
	"strings"
	"text/template"
)

// Render the command line usage message
func RenderUsageTemplate(confirm string, debug string, fonts []FontSpec) string {
	context := usageTemplateContext{confirm, debug, fonts}
	return renderTemplate(usageTemplate, "usage", context)
}

// Render rust source code for font file with index functions and static arrays
func RenderFontFileTemplate(f FontSpec, gs GlyphSet) string {
	context := fontFileTemplateContext{f, gs}
	return renderTemplate(fontFileTemplate, "fontfile", context)
}

// Holds data for rendering usageTemplate
type usageTemplateContext struct {
	Confirm string
	Debug   string
	Fonts   []FontSpec
}

// Holds data for rendering fontFileTemplate
type fontFileTemplateContext struct {
	Font FontSpec
	GS   GlyphSet
}

// Return a string from rendering the given template and context data
func renderTemplate(templateString string, name string, context interface{}) string {
	fmap := template.FuncMap{"ToLower": strings.ToLower}
	t := template.Must(template.New(name).Funcs(fmap).Parse(templateString))
	var buf bytes.Buffer
	err := t.Execute(&buf, context)
	if err != nil {
		panic(err)
	}
	return buf.String()
}

// Template with usage instructions for the command line tool
const usageTemplate = `
This tool generates fonts in the form of rust source code.
To confirm that you want to write the files, use the {{.Confirm}} switch.
To show debug info, use the {{.Debug}} switch.

Font files that will be generated:{{range $f := .Fonts}}
  {{$f.RustOut}}{{end}}

Usage:
    go run main.go {{.Confirm}}
`

// Template with rust source code for a outer structure of a font file
const fontFileTemplate = `// DO NOT MAKE EDITS HERE because this file is automatically generated.
// To make changes, see blitstr2/codegen/main.go
//
{{.Font.Legal}}
//! {{.Font.Name}} Font
#![allow(dead_code)]

/// Maximum height of glyph patterns in this bitmap typeface.
pub const MAX_HEIGHT: u8 = {{.Font.Size}};

/// Unicode character codepoints corresponding to glyph sprites in GLYPHS array.
/// Indended use:
///  1. Do binary search on CODEPOINTS to find index of the codepoint corresponding
///     to the glyph you want to locate
///  2. Multiply resulting CODEPOINTS index by 8 (<<3) to get index into GLYPHS for
///     the corresponding glyph sprite (because 16*16px sprite size is 8*u32)
pub const CODEPOINTS: [u32; {{.GS.CodepointsLen}}] = [
{{.GS.Codepoints}}];

/// Packed 16px * 16px glyph pattern data.
/// Pixels are packed in row-major order with LSB of first pixel word
/// containing the top left pixel. Bit of 0 means clear, 1 means set
pub const GLYPHS: [u32; {{.GS.GlyphsLen}}] = [
{{.GS.Glyphs}}];
{{if .GS.Widths}}
/// Widths for proportional glyphs
pub const WIDTHS: [u8; {{.GS.WidthsLen}}] = [
{{.GS.Widths}}];
{{end}}`
